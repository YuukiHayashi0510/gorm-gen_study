// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"study/internal/db/model"
)

func newSalesProduct(db *gorm.DB, opts ...gen.DOOption) salesProduct {
	_salesProduct := salesProduct{}

	_salesProduct.salesProductDo.UseDB(db, opts...)
	_salesProduct.salesProductDo.UseModel(&model.SalesProduct{})

	tableName := _salesProduct.salesProductDo.TableName()
	_salesProduct.ALL = field.NewAsterisk(tableName)
	_salesProduct.SalesID = field.NewString(tableName, "sales_id")
	_salesProduct.ProductID = field.NewString(tableName, "product_id")
	_salesProduct.ProductName = field.NewString(tableName, "product_name")
	_salesProduct.Count_ = field.NewInt32(tableName, "count")
	_salesProduct.SalesPrice = field.NewInt64(tableName, "sales_price")
	_salesProduct.SalesDate = field.NewTime(tableName, "sales_date")
	_salesProduct.TaxStatus = field.NewInt32(tableName, "tax_status")
	_salesProduct.IsReturned = field.NewInt32(tableName, "is_returned")
	_salesProduct.Product = salesProductBelongsToProduct{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Product", "model.Product"),
		SubCategory: struct {
			field.RelationField
			Category struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Product.SubCategory", "model.SubCategory"),
			Category: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Product.SubCategory.Category", "model.Category"),
			},
		},
	}

	_salesProduct.fillFieldMap()

	return _salesProduct
}

type salesProduct struct {
	salesProductDo

	ALL         field.Asterisk
	SalesID     field.String
	ProductID   field.String
	ProductName field.String
	Count_      field.Int32
	SalesPrice  field.Int64
	SalesDate   field.Time
	TaxStatus   field.Int32
	IsReturned  field.Int32
	Product     salesProductBelongsToProduct

	fieldMap map[string]field.Expr
}

func (s salesProduct) Table(newTableName string) *salesProduct {
	s.salesProductDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s salesProduct) As(alias string) *salesProduct {
	s.salesProductDo.DO = *(s.salesProductDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *salesProduct) updateTableName(table string) *salesProduct {
	s.ALL = field.NewAsterisk(table)
	s.SalesID = field.NewString(table, "sales_id")
	s.ProductID = field.NewString(table, "product_id")
	s.ProductName = field.NewString(table, "product_name")
	s.Count_ = field.NewInt32(table, "count")
	s.SalesPrice = field.NewInt64(table, "sales_price")
	s.SalesDate = field.NewTime(table, "sales_date")
	s.TaxStatus = field.NewInt32(table, "tax_status")
	s.IsReturned = field.NewInt32(table, "is_returned")

	s.fillFieldMap()

	return s
}

func (s *salesProduct) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *salesProduct) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 9)
	s.fieldMap["sales_id"] = s.SalesID
	s.fieldMap["product_id"] = s.ProductID
	s.fieldMap["product_name"] = s.ProductName
	s.fieldMap["count"] = s.Count_
	s.fieldMap["sales_price"] = s.SalesPrice
	s.fieldMap["sales_date"] = s.SalesDate
	s.fieldMap["tax_status"] = s.TaxStatus
	s.fieldMap["is_returned"] = s.IsReturned

}

func (s salesProduct) clone(db *gorm.DB) salesProduct {
	s.salesProductDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s salesProduct) replaceDB(db *gorm.DB) salesProduct {
	s.salesProductDo.ReplaceDB(db)
	return s
}

type salesProductBelongsToProduct struct {
	db *gorm.DB

	field.RelationField

	SubCategory struct {
		field.RelationField
		Category struct {
			field.RelationField
		}
	}
}

func (a salesProductBelongsToProduct) Where(conds ...field.Expr) *salesProductBelongsToProduct {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a salesProductBelongsToProduct) WithContext(ctx context.Context) *salesProductBelongsToProduct {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a salesProductBelongsToProduct) Session(session *gorm.Session) *salesProductBelongsToProduct {
	a.db = a.db.Session(session)
	return &a
}

func (a salesProductBelongsToProduct) Model(m *model.SalesProduct) *salesProductBelongsToProductTx {
	return &salesProductBelongsToProductTx{a.db.Model(m).Association(a.Name())}
}

type salesProductBelongsToProductTx struct{ tx *gorm.Association }

func (a salesProductBelongsToProductTx) Find() (result *model.Product, err error) {
	return result, a.tx.Find(&result)
}

func (a salesProductBelongsToProductTx) Append(values ...*model.Product) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a salesProductBelongsToProductTx) Replace(values ...*model.Product) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a salesProductBelongsToProductTx) Delete(values ...*model.Product) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a salesProductBelongsToProductTx) Clear() error {
	return a.tx.Clear()
}

func (a salesProductBelongsToProductTx) Count() int64 {
	return a.tx.Count()
}

type salesProductDo struct{ gen.DO }

type ISalesProductDo interface {
	gen.SubQuery
	Debug() ISalesProductDo
	WithContext(ctx context.Context) ISalesProductDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISalesProductDo
	WriteDB() ISalesProductDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISalesProductDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISalesProductDo
	Not(conds ...gen.Condition) ISalesProductDo
	Or(conds ...gen.Condition) ISalesProductDo
	Select(conds ...field.Expr) ISalesProductDo
	Where(conds ...gen.Condition) ISalesProductDo
	Order(conds ...field.Expr) ISalesProductDo
	Distinct(cols ...field.Expr) ISalesProductDo
	Omit(cols ...field.Expr) ISalesProductDo
	Join(table schema.Tabler, on ...field.Expr) ISalesProductDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISalesProductDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISalesProductDo
	Group(cols ...field.Expr) ISalesProductDo
	Having(conds ...gen.Condition) ISalesProductDo
	Limit(limit int) ISalesProductDo
	Offset(offset int) ISalesProductDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISalesProductDo
	Unscoped() ISalesProductDo
	Create(values ...*model.SalesProduct) error
	CreateInBatches(values []*model.SalesProduct, batchSize int) error
	Save(values ...*model.SalesProduct) error
	First() (*model.SalesProduct, error)
	Take() (*model.SalesProduct, error)
	Last() (*model.SalesProduct, error)
	Find() ([]*model.SalesProduct, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SalesProduct, err error)
	FindInBatches(result *[]*model.SalesProduct, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SalesProduct) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISalesProductDo
	Assign(attrs ...field.AssignExpr) ISalesProductDo
	Joins(fields ...field.RelationField) ISalesProductDo
	Preload(fields ...field.RelationField) ISalesProductDo
	FirstOrInit() (*model.SalesProduct, error)
	FirstOrCreate() (*model.SalesProduct, error)
	FindByPage(offset int, limit int) (result []*model.SalesProduct, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISalesProductDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s salesProductDo) Debug() ISalesProductDo {
	return s.withDO(s.DO.Debug())
}

func (s salesProductDo) WithContext(ctx context.Context) ISalesProductDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s salesProductDo) ReadDB() ISalesProductDo {
	return s.Clauses(dbresolver.Read)
}

func (s salesProductDo) WriteDB() ISalesProductDo {
	return s.Clauses(dbresolver.Write)
}

func (s salesProductDo) Session(config *gorm.Session) ISalesProductDo {
	return s.withDO(s.DO.Session(config))
}

func (s salesProductDo) Clauses(conds ...clause.Expression) ISalesProductDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s salesProductDo) Returning(value interface{}, columns ...string) ISalesProductDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s salesProductDo) Not(conds ...gen.Condition) ISalesProductDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s salesProductDo) Or(conds ...gen.Condition) ISalesProductDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s salesProductDo) Select(conds ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s salesProductDo) Where(conds ...gen.Condition) ISalesProductDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s salesProductDo) Order(conds ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s salesProductDo) Distinct(cols ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s salesProductDo) Omit(cols ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s salesProductDo) Join(table schema.Tabler, on ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s salesProductDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s salesProductDo) RightJoin(table schema.Tabler, on ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s salesProductDo) Group(cols ...field.Expr) ISalesProductDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s salesProductDo) Having(conds ...gen.Condition) ISalesProductDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s salesProductDo) Limit(limit int) ISalesProductDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s salesProductDo) Offset(offset int) ISalesProductDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s salesProductDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISalesProductDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s salesProductDo) Unscoped() ISalesProductDo {
	return s.withDO(s.DO.Unscoped())
}

func (s salesProductDo) Create(values ...*model.SalesProduct) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s salesProductDo) CreateInBatches(values []*model.SalesProduct, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s salesProductDo) Save(values ...*model.SalesProduct) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s salesProductDo) First() (*model.SalesProduct, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SalesProduct), nil
	}
}

func (s salesProductDo) Take() (*model.SalesProduct, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SalesProduct), nil
	}
}

func (s salesProductDo) Last() (*model.SalesProduct, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SalesProduct), nil
	}
}

func (s salesProductDo) Find() ([]*model.SalesProduct, error) {
	result, err := s.DO.Find()
	return result.([]*model.SalesProduct), err
}

func (s salesProductDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SalesProduct, err error) {
	buf := make([]*model.SalesProduct, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s salesProductDo) FindInBatches(result *[]*model.SalesProduct, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s salesProductDo) Attrs(attrs ...field.AssignExpr) ISalesProductDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s salesProductDo) Assign(attrs ...field.AssignExpr) ISalesProductDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s salesProductDo) Joins(fields ...field.RelationField) ISalesProductDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s salesProductDo) Preload(fields ...field.RelationField) ISalesProductDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s salesProductDo) FirstOrInit() (*model.SalesProduct, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SalesProduct), nil
	}
}

func (s salesProductDo) FirstOrCreate() (*model.SalesProduct, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SalesProduct), nil
	}
}

func (s salesProductDo) FindByPage(offset int, limit int) (result []*model.SalesProduct, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s salesProductDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s salesProductDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s salesProductDo) Delete(models ...*model.SalesProduct) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *salesProductDo) withDO(do gen.Dao) *salesProductDo {
	s.DO = *do.(*gen.DO)
	return s
}
